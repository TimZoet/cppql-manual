% TODO: Conversions between differently sized ints, nulls, etc, during all operations (select, insert, update, etc.).


\subsection{Expressions}
\label{section:hli:expression}

% Binding values: value (fixed) vs pointers (dynamic).
% Order by: -col1 + col2 becomes ORDER BY col1 DESC, col2 ASC;
% How do text and blobs work?

\subsection{Insert}
\label{section:hli:insert}

To insert new rows into a table, you can construct an \code{Insert} object from a typed table. This object holds a statement of the form \code{INSERT INTO ...}, which is used to add the new data. See Listing~\ref{lst:hli:insert_create}

\lstinputlisting[caption={Creating a typed insert statement.}, label={lst:hli:insert_create}]{snippets/insert_create.cpp}

The insert object is callable with either separate values for each column, or a tuple. See Listing~\ref{lst:hli:insert_call}.

\lstinputlisting[caption={Inserting new rows.}, label={lst:hli:insert_call}]{snippets/insert_call.cpp}

To insert the default value for a column, or to have e.g. primary keys properly auto increment, simply pass a \code{nullptr} instead of a value. See Listing~\ref{lst:hli:insert_default}.

\lstinputlisting[caption={Passing a nullptr to use default value for primary key.}, label={lst:hli:insert_default}]{snippets/insert_default.cpp}

A single insert object reuses the same prepared statement each time a row is added. It can be called any number of times. Multiple insert objects do not share this statement. To limit the number of times new statements are prepared, reuse the same insert object as much as you can.

\subsection{Delete}
\label{section:hli:delete}

To remove rows from a table, you can construct a \code{Delete} object from a typed table. This objects holds a statement of the form \code{DELETE FROM <table> WHERE <expr>}. See Listing~\ref{lst:hli:delete_create}.

\lstinputlisting[caption={Creating a delete statement.}, label={lst:hli:delete_create}]{snippets/delete_create.cpp}

The first parameter is the expression by which to filter. The second parameter indicates whether expression parameters should be bound immediately upon creation. After construction, the object can be invoked one or more times. See Listing~\ref{lst:hli:delete_call}.

\lstinputlisting[caption={Deleting multiple rows.}, label={lst:hli:delete_call}]{snippets/delete_call.cpp}

There are two overloads of \code{operator()}. The first does not take any parameters and runs the delete statement without (re)binding any parameters. The second accepts a boolean parameter which, if true, will result in all parameters being bound before running the delete. If the filter expression does not have dynamic parameters it is best to bind upon construction and then invoke the parameterless function. This will result in the best performance.

\subsection{Select}
\label{section:hli:select}

% TODO: select, selectOne, selectN, selectAll
% TODO: Blobs.

It is also possible to use custom return types, instead of just tuples. To do so, pass your type as the first template parameter to the \code{select} method. The only requirement on the type is that it has a constructor that takes all selected column values. See Listing~\ref{lst:hli:select_custom_type}.

\lstinputlisting[caption={Retrieve results as custom type.}, label={lst:hli:select_custom_type}]{snippets/select_custom_type.cpp}

Since the \code{Select} class has a \code{begin} and \code{end} method, you can also directly construct e.g. a \code{std::vector} from it. See Listing~\ref{lst:hli:select_to_container}.

\lstinputlisting[caption={Constructing a vector from a select object.}, label={lst:hli:select_to_container}]{snippets/select_to_container.cpp}


\subsection{Count}
\label{section:hli:count}
