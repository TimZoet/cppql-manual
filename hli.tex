% TODO: Conversions between differently sized ints, nulls, etc, during all operations (select, insert, update, etc.).


\subsection{Expressions}
\label{section:hli:expression}

% Binding values: value vs pointers.
% Order by: -col1 + col2 becomes ORDER BY col1 DESC, col2 ASC;

\subsection{Insert}
\label{section:hli:insert}

To insert new rows into a table, you can construct an \code{Insert} object from a typed table. This object holds a statement of the form \code{INSERT INTO ...}, which is used to add the new data. See Listing~\ref{lst:hli:insert_create}

\lstinputlisting[caption={Creating a typed insert statement.}, label={lst:hli:insert_create}]{snippets/insert_create.cpp}

The insert object is callable with either separate values for each column, or a tuple. See Listing~\ref{lst:hli:insert_call}.

\lstinputlisting[caption={Inserting new rows.}, label={lst:hli:insert_call}]{snippets/insert_call.cpp}

To insert the default value for a column, or to have e.g. primary keys properly auto increment, simply pass a \code{nullptr} instead of a value. See Listing~\ref{lst:hli:insert_default}.

\lstinputlisting[caption={Passing a nullptr to use default value for primary key.}, label={lst:hli:insert_default}]{snippets/insert_default.cpp}

A single insert object reuses the same prepared statement each time a row is added. It can be called any number of times. Multiple insert objects do not share this statement. To limit the number of times new statements are prepared, reuse the same insert object as much as you can.

\subsection{Delete}
\label{section:hli:delete}

\subsection{Select}
\label{section:hli:select}


% TODO: select, selectOne, selectN, selectAll
% TODO: Blobs.

It is also possible to use custom return types, instead of just tuples. To do so, pass your type as the first template parameter to the \code{select} method. The only requirement on the type is that it has a constructor that takes all selected column values. See Listing~\ref{lst:hli:select_custom_type}.

\lstinputlisting[caption={Retrieve results as custom type.}, label={lst:hli:select_custom_type}]{snippets/select_custom_type.cpp}

Since the \code{Select} class has a \code{begin} and \code{end} method, you can also directly construct e.g. a \code{std::vector} from it. See Listing~\ref{lst:hli:select_to_container}.

\lstinputlisting[caption={Constructing a vector from a select object.}, label={lst:hli:select_to_container}]{snippets/select_to_container.cpp}





\subsection{Count}
\label{section:hli:count}
