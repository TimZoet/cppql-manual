To select rows in a table, you can construct a \gls{select_class} object from a \gls{typed_table_class}. This object holds a statement of the form \newline \code{SELECT <cols> FROM <table> WHERE <expr>}. See Listing~\ref{lst:select:create}.

\lstinputlisting[caption={Creating a select statement.}, label={lst:select:create}]{snippets/select_create.cpp}

The first parameter is the expression by which to \marginlabel{See Section~\ref{section:typed_tables:filter}.}filter. The second parameter indicates whether expression parameters should be bound immediately upon creation. After construction, the object can be iterated over one or more times to retrieve the results. See Listing~\ref{lst:select:iterate}.

\lstinputlisting[caption={Retrieving select results.}, label={lst:select:iterate}]{snippets/select_iterate.cpp}

Iterating over the select object will first reset the statement. If you want to (re)bind parameters, call \code{operator(true)} before iteration. Since this operator returns a reference to the select object itself, you can e.g. use it in a range based for loop: \code{for (auto row : select(true))\{...\}}.

Some notes on the internal implementation details. Calling the \code{begin} method will run \code{sqlite3\_step} and return an iterator. Each time the iterator is incremented, \code{sqlite3\_step} is called. The \code{end} method returns a dummy iterator value. The end of the sequence is determined using the return code of \code{sqlite3\_step}.

\subsection{Custom Return Types}
\label{section:select:custom}

It is also possible to use custom return types, instead of just tuples. To do so, pass your type as the first template parameter to the \code{select} method. The only requirement on the type is that it has a constructor that takes all selected column values. See Listing~\ref{lst:select:custom_type}.

\lstinputlisting[caption={Retrieve results as custom type.}, label={lst:select:custom_type}]{snippets/select_custom_type.cpp}

\subsection{Containers}
\label{section:select:container}

Since the \code{Select} class has a \code{begin} and \code{end} method, you can also directly construct e.g. a \code{std::vector} from it. See Listing~\ref{lst:select:to_container}.

\lstinputlisting[caption={Constructing a vector from a select object.}, label={lst:select:to_container}]{snippets/select_to_container.cpp}

\subsection{Select One}
\label{section:select:one}

If you wish to construct a query that is expected to return exactly one row, there is the \code{selectOne} method. This method returns a callable object that directly produces a value instead of an iterator. If no or more than one rows match the query, an exception is thrown. See Listing~\ref{lst:select:select_one}.

\lstinputlisting[caption={Retrieve exactly one row.}, label={lst:select:select_one}]{snippets/select_one.cpp}

\subsection{Select All}
\label{section:select:all}

It is also possible to select all rows in a table with the \code{selectAll} method. This returns the same type of object as a normal select, just without a filter expression. See Listing~\ref{lst:select:select_all}.

\lstinputlisting[caption={Retrieve all rows.}, label={lst:select:select_all}]{snippets/select_all.cpp}

\subsection{Order By, Limit and Offset}
\label{section:select:limit}

All select methods (except of course \code{selectOne}) support the ordering and limiting off results. See Section~\ref{section:typed_tables:order} and Section~\ref{section:typed_tables:limit}.

