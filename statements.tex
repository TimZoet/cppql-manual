The \gls{statement_class} class is a wrapper around a \gls{sqlite} statement object. It has methods to prepare queries, bind parameters and retrieve results. Similar to the \gls{database_class}, it does not support all C API functions. Use the \code{get} method to retrieve the internal handle.

\subsection{Preparing Statements}
\label{section:statement:create}

Statements can be created through the \code{createStatement} method of a \gls{database_class}. The first parameter is the SQL query to be executed. The second parameter indicates whether the statement should be prepared immediately. See Listing~\ref{lst:statement:create}.

\lstinputlisting[caption={Creating a statement.}, label={lst:statement:create}]{snippets/create_statement.cpp}

Statements are only valid as long as the database they belong to is valid. Calling any method on a statement after the database went out of scope will result in unpredictable behaviour.

Once a statement is prepared, the \code{step} and \code{reset} methods can be called. These correspond directly to the \code{sqlite3\_step} and \code{sqlite3\_reset} C functions.

\subsection{Binding Parameters}
\label{section:statement:bind}

The \code{sqlite3\_bind\_*} functions can all be called through methods on the \gls{statement_class} object. There is also a template method that can bind multiple parameters at once and is a bit more flexible in the types it accepts. Note that all these methods use 0-based indices, instead of the 1-based indices that the underlying C functions use.

The \code{bindInt}, \code{bindInt64}, \code{bindFloat}, \code{bindDouble} and \code{bindNull} methods are pretty self-explanatory. They directly pass on the value parameter to the appropriate C function. See Listing~\ref{lst:statement:bind_simple}.

\lstinputlisting[caption={Binding some simple values.}, label={lst:statement:bind_simple}]{snippets/bind_simple.cpp}

\Gls{sqlite} offers 3 ways of binding text: by taking ownership of the data, by copying it, or by assuming the data will exist until the statement is freed or different data is bound. Each of these ways has a corresponding method: \code{bindText}, \code{bindTransientText} and \code{bindStaticText} respectively. See Listing~\ref{lst:statement:bind_text}.

\lstinputlisting[caption={Binding text.}, label={lst:statement:bind_text}]{snippets/bind_text.cpp}

The blob binding methods follow the same principle as the ones for binding text.

To clear all bindings, call the \code{clearBindings} method.

In addition to the various methods that only bind a single value, there is a template \code{bind} method that can take an arbitrary number of parameters of any type. The first parameter is the index of the first column to bind a value to. For each subsequent parameter, a call to the appropriate bind function is made. Binding integral and floating point types is a bit more flexible since \marginlabel{See Table~\ref{table:statement:mapping} for mapping.}automatic casts are performed. Binding text and blobs requires some more care. In order to distinguish between the various types of ownership, you must wrap a pointer in a \gls{text_class} or \gls{blob_class} object. There are several utility functions (e.g. \code{toStaticBlob}) to quickly put (vectors of) objects in wrappers. See Listing~\ref{lst:statement:bind_template}.

\lstinputlisting[caption={Template bind method.}, label={lst:statement:bind_template}]{snippets/bind_template.cpp}

\begin{table}[H]
\caption{Mapping of input types and bind functions.}\label{table:statement:mapping}
\centering
\begin{tabular}{| p{20mm} | p{40mm} | p{32mm} |}
Input Type & Conversion & Bind Function \\
\hline\hline
int32 & none & \code{bindInt} \\
int64 & none & \code{bindInt64} \\
double & none & \code{bindDouble} \\
nullptr\_t & none & \code{bindNull} \\
\hline
uint32 & \code{bit\_cast<int32>} & \code{bindInt} \\
(u)int(8 $\vert$ 16) & \code{static\_cast<int32>} & \code{bindInt} \\
uint64 & \code{bit\_cast<int64>} & \code{bindInt64} \\
float & \code{static\_cast<double>} & \code{bindDouble} \\
\hline
Text & none & \code{bindText} \\
StaticText & none & \code{bindStaticText} \\
TransientText & none & \code{bindTransientText} \\
Blob & none & \code{bindBlob} \\
StaticBlob & none & \code{bindStaticBlob} \\
TransientBlob & none & \code{bindTransientBlob} \\
\hline
\end{tabular}
\end{table}

\subsection{Getting Columns}
\label{section:statement:get}

Similar to the bind functions. the \code{sqlite3\_column\_*} functions to retrieve results are all available through methods on the \gls{statement_class} object.

Getting integers, floats and strings is straightforward. Just call the \code{column} method with the (0-based) index and pass a variable by reference. Any required conversions are performed by \gls{sqlite} itself. See Listing~\ref{lst:statement:get_column_simple}.

\lstinputlisting[caption={Getting some simple values.}, label={lst:statement:get_column_simple}]{snippets/get_column_simple.cpp}

If you wish to verify a column type before retrieving the value, call the \code{columnType} method, which wraps around the \code{sqlite3\_column\_type} function. See Listing~\ref{lst:statement:get_column_type}.

\lstinputlisting[caption={Getting a column's type.}, label={lst:statement:get_column_type}]{snippets/get_column_type.cpp}

Blob values can be retrieved as (vectors of) arbitrary types. See Listing~\ref{lst:statement:get_column_blob}.

\lstinputlisting[caption={Getting blob columns.}, label={lst:statement:get_column_blob}]{snippets/get_column_blob.cpp}

On top of the separate methods there is also a template method that returns columns by value. Furthermore, it will perform some integer casts when necessary, similar to what the \code{bind} method does. See Listing~\ref{lst:statement:get_column_template}.

\lstinputlisting[caption={Template column method.}, label={lst:statement:get_column_template}]{snippets/get_column_template.cpp}